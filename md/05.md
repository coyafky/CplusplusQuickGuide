#### 友元函数和友元类

友元的作用举例来说--写一个神经网络，写完以后想写一个单元测试，和神经网络放在一个命名空间里。写的神经网络是一个类，里面有多个私有变量，而单元测试不可避免地要用到这些私有变量。如果这是在java里，我就只能再写上一堆访问器了；而在C++里，只用把这个单元测试函数声明成类的友元，就能随心所欲地访问私有变量，简直不要太痛快。

但同时也需要慎用friend关键字，它会破坏掉封装的隐藏性。


##### 友元函数

如果一个函数被定义为一个类的友元函数，那么这个函数可以访问所有私有和受保护的数据。

要使函数成为类的友元函数，可以在类内部以private或public部分的形式声明它，并在声明之前加上关键字friend，如下所示。

```C++
class Temperature
{
    int celsius;
    public:
        Temperature():celsius(0);

        friend int temp( Temperature );   //声明友元函数
};
```
这里，temp是类Temperature的友元函数。因此，它可以访问类的所有私有成员和受保护成员。

```C++
#include <iostream>

using namespace std;

class Temperature
{
	int celsius;
	public:
		Temperature():celsius(0);

		friend int temp( Temperature );   
};

int temp( Temperature t )     // 友元函数定义
{
	t.celsius = 40;
	return t.celsius;
}

int main()
{
	Temperature tm;
	cout << "Temperature in celsius : " << temp( tm ) << endl;
	return 0;
}
//OUTPUT:Temperature in celsius : 40
```
声明了一个函数“temp”作为类“Temperature”的友元函数。在friend函数中，我们直接访问了类'Temperature'的私有成员摄摄氏度。
主函数的第一个语句创建了类'Temperature'的对象'tm'，从而调用其构造函数，并为其数据成员摄氏度赋值0。
主函数的第二个语句调用temp函数，它为摄氏温度赋值40。

两个类的同一个f可以有同一个友元函数。
```C++
#include <iostream>

using namespace std;

class B;       //declaration of class B

class A
{
	int value;
	public:
		A():value(5){}

		friend int sum(A, B);     // 声明友元函数
};

class B
{
	int value;
	public:
		B():value(3);

		friend int sum(A, B);     // 声明友元函数
};

int sum( A v1, B v2 )             // 定义友元函数
{
	return (v1.value + v2.value);
}

int main()
{
	A a;
	B b;
	cout << "Sum : " << sum( a, b ) << endl;
	return 0;
}
//OUTPUT:Sum : 8
```
在本例中，将sum()声明为a和b类的friend函数。因此，该函数现在可以访问这两个类的私有成员和受保护成员。这两个类的对象都作为函数的参数传递。

**注意，我们在定义类A之前声明了类B，因为在类A的主体中，friend函数接受参数'A'和'B'。**

#### 友元类

在学校里能使一个班成为另一个班的朋友。在这种情况下，类中声明为friend的所有成员函数将成为另一个类的friend函数。

```C++
class A
{
    friend class B;

};

class B
{

};
```
上面的代码中，B类被声明为a类的朋友。所以现在B类的所有成员函数都变成了A类的友元函数。